attacker [active]

principal Server[

]

// The User here is both a client and CA
principal User[
    // Generate CA key pair
    knows private ca_sk
    ca_pk = G^ca_sk

    // Securely generate his signing key pair
    knows private static_signing_key_sk_user
    static_signing_key_pk_user = G^static_signing_key_sk_user

    // Sign the static public key
    static_signing_key_pk_user_sig = SIGN(ca_sk,static_signing_key_pk_user)
]

User -> Server: static_signing_key_pk_user, static_signing_key_pk_user_sig

principal User[
    // Create new instance by generating a new key pair and signing it
    knows private static_signing_key_sk_instance
    static_signing_key_pk_instance = G^static_signing_key_sk_instance

    // Sign the static public key
    static_signing_key_pk_instance_sig = SIGN(ca_sk,static_signing_key_pk_instance)
]

User -> Server: static_signing_key_pk_instance, static_signing_key_pk_instance_sig

principal Instance[
    // This is an OTR communication
    knows private static_signing_key_sk_instance
]

// This is an OTR communication
User -> Instance: [ca_pk]

Server -> Instance: static_signing_key_pk_user, static_signing_key_pk_user_sig


// User initiates a Diffie-Hellman key exchange with the server
// Therefore the User generates an ephemeral key pair and signs it

principal User[
    // Securely generate his ephemeral key pair
    generates ephemeral_signing_key_sk_user
    ephemeral_signing_key_pk_user = G^ephemeral_signing_key_sk_user

    // Sign the ephemeral public key
    ep_pk_user_sig = SIGN(static_signing_key_sk_user,ephemeral_signing_key_pk_user)
]

// Send the signed ephemeral public key to the Instance
User -> Instance: ephemeral_signing_key_pk_user,ep_pk_user_sig

// The Instance verifies the signature and generates his ephemeral key pair

principal Instance[
    // Verify the signature of the users static public key
    valid_s_u = SIGNVERIF(ca_pk,static_signing_key_pk_user,static_signing_key_pk_user_sig)?

    // Verify the signature
    valid_e_u = SIGNVERIF(static_signing_key_pk_user,ephemeral_signing_key_pk_user,ep_pk_user_sig)?

    // Securely generate his ephemeral key pair
    generates ephemeral_signing_key_sk_instance
    ephemeral_signing_key_pk_instance = G^ephemeral_signing_key_sk_instance

    // Sign the ephemeral public key
    ep_pk_instance_sig = SIGN(static_signing_key_sk_instance,ephemeral_signing_key_pk_instance)

    // Compute the shared secret
    shared_secret_instance = ephemeral_signing_key_pk_user^ephemeral_signing_key_sk_instance
]

// Send the signed ephemeral public key to the User
Instance -> User: ephemeral_signing_key_pk_instance,ep_pk_instance_sig

// The User verifies the signature and computes the shared secret
// The Instance verifies the signature and computes the shared secret

principal User[
    // Verify the signature of the instances static public key
    valid_s_i = SIGNVERIF(ca_pk, static_signing_key_pk_instance,static_signing_key_pk_instance_sig)?
    // Verify the signature
    valid_e_i = SIGNVERIF(static_signing_key_pk_instance,ephemeral_signing_key_pk_instance,ep_pk_instance_sig)?

    // Compute the shared secret
    shared_secret_user = ephemeral_signing_key_pk_instance^ephemeral_signing_key_sk_user
]

// Send a message using the shared secret

principal User[
    // Encrypt the message
    generates message
    generates metadata // timestamp, nonce, etc.
    ciphertext = AEAD_ENC(shared_secret_user,message,metadata)

    // Generate ciphertext hash and sign it
    message_hash = HASH(message)

    // Sign the hash
    signature = SIGN(ephemeral_signing_key_sk_user,message_hash)
]

User -> Instance: ciphertext, metadata, signature

principal Instance[
    // Decrypt the message
    message_decrypted = AEAD_DEC(shared_secret_instance,ciphertext,metadata)?

    // Verify the signature
    // 1. Generate the hash
    message_hash_dec = HASH(message_decrypted)

    // 2. Verify the signature
    valid_signature = SIGNVERIF(ephemeral_signing_key_pk_user,message_hash_dec,signature)?

]




queries [
    equivalence? shared_secret_instance, shared_secret_user
    confidentiality? ephemeral_signing_key_sk_user
    confidentiality? ephemeral_signing_key_sk_instance
    confidentiality? shared_secret_instance
    confidentiality? shared_secret_user
    confidentiality? message
    confidentiality? ca_sk
    freshness? ephemeral_signing_key_pk_user
    freshness? ephemeral_signing_key_pk_instance
    equivalence? message, message_decrypted
    equivalence? message_hash, message_hash_dec
]
